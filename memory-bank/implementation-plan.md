# 《仿蛊》MVP实施计划

本文档是游戏《仿蛊》(Fang Gu) 的最小可行产品（MVP）的详细实施计划。它旨在通过一系列小而具体、可测试的步骤，指导您完成游戏核心框架的搭建。

---

## 里程碑 1: 世界与玩家

**目标**: 建立游戏的基本环境，并实现一个可以移动和拥有基础属性的玩家角色。

| 步骤 | 实施指令 | 测试标准 |
| :--- | :--- | :--- |
| **1.1** | **项目设置**：初始化一个新的Unity 2D项目。创建基础文件夹结构：`_Scripts`, `_Scenes`, `_Prefabs`, `_Sprites`。 | Unity项目可以无错误地打开。在`Assets`视图中可以看到指定的文件夹。 |
| **1.2** | **创建玩家角色**：创建一个`Player`游戏对象。添加一个`SpriteRenderer`组件并赋予一个占位符精灵图。添加`Rigidbody2D`（设置为`Kinematic`或`Dynamic`且重力为0）和`Collider2D`组件。 | 在一个新场景中放置`Player`对象。进入播放模式，玩家对象可见且不会掉出屏幕。 |
| **1.3** | **玩家移动**：创建一个`PlayerMovement`脚本。实现基于键盘输入（WASD或方向键）的上下左右四向移动逻辑。在玩家进行任何施法操作时，移动不受限制。 | 进入播放模式，按下移动键，角色在对应方向上移动。在模拟施法时（即使只是按下'J'键），玩家依然可以移动。 |
| **1.4** | **玩家属性**：创建一个`PlayerStats`脚本。定义核心属性变量：HP, MaxHP, MP, MaxMP, EXP, Level, SoulForce, AD, AP, Defense。并用初始值（如等级1，100 HP, 0 SoulForce等）进行初始化。添加一个布尔状态 `isBreakthroughPending`，默认为false。 | 将`PlayerStats`脚本附加到`Player`对象上。进入播放模式并检视该对象，所有属性都应在Inspector中可见并显示正确的初始值。 |
| **1.5** | **创建基础地图**：为第一个地图（如 "荒野_1"）创建一个新场景。使用Unity的`Tilemap`系统绘制一个简单的、封闭的区域供玩家移动。为地图边界添加碰撞体。 | 将玩家放置在"荒野_1"场景中。进入播放模式，玩家可以在区域内移动，但会被地图边界阻挡。 |
| **1.6** | **俯视角相机**：创建一个`CameraFollow`脚本并附加到主相机上。实现使相机位置平滑跟随玩家位置的逻辑。 | 进入播放模式，在地图上移动玩家。相机应始终跟随玩家，使其保持在屏幕中心。 |
| **1.7** | **时间管理系统**：创建一个`TimeManager`单例。它负责管理全局`Time.timeScale`。实现`RequestTimeScale(string key, float scale)`和`ReleaseTimeScale(string key)`方法。该管理器应能处理多个时间缩放请求，并应用所有请求中的最低值。 | 调用`RequestTimeScale("req1", 0.5f)`和`RequestTimeScale("req2", 0.2f)`后，`Time.timeScale`应变为0.2。释放"req2"后，应恢复为0.5。全部释放后，恢复为1.0。 |

---

## 里程碑 2: 核心战斗机制

**目标**: 实现玩家与敌人之间的基本战斗交互循环。

| 步骤 | 实施指令 | 测试标准 |
| :--- | :--- | :--- |
| **2.1**| **普通攻击**：创建一个`PlayerAttack`脚本。实现按下'H'键时，根据玩家朝向，在前方短暂生成一个"攻击判定区"（一个触发器碰撞体）。 | 将脚本附加到玩家上。进入播放模式并启用Gizmos。按下'H'键时，应能在正确方向上看到攻击判定区的Gizmo。 |
| **2.2**| **创建简单敌人**：创建一个`Enemy`预制件。它应包含`SpriteRenderer`、`Collider2D`、以及一个带有HP属性的`EnemyStats`脚本和一个`EnemyAI`脚本。 | 将`Enemy`预制件拖入场景。它应该是可见的。其HP值应可以在Inspector中配置。 |
| **2.3**| **敌人AI（简单）**：在`EnemyAI`脚本中，实现简单的状态机行为：1. 探测半径内发现玩家则进入"追击"状态。2. 接触到玩家则进入"攻击"状态，造成一次伤害，然后立刻进入"冷却"状态并向后退一小段距离。3. 冷却结束后返回"追击"状态。 | 在场景中放置一个敌人和玩家。当玩家足够靠近时，敌人开始朝玩家移动。接触后，敌人造成伤害并后退，在短暂延迟后才再次追击。 |
| **2.4**| **造成伤害**：在`PlayerAttack`脚本中，检测攻击判定区是否与标记为"Enemy"的对象发生碰撞。如果是，则调用一个全局的`DamageCalculator`来计算伤害。**架构**：创建一个`IDamageCalculator`接口和一个`BasicADCalculator`实现类，该类根据攻击者的AD值计算伤害。`PlayerAttack`通过接口调用。 | 放置一个敌人。玩家靠近并按下'H'键。敌人的HP（在Inspector中可见或通过Debug日志查看）应会根据`BasicADCalculator`的计算结果减少。 |
| **2.5**| **受到伤害**：在`EnemyAI`脚本中，实现敌人通过接触（`OnCollisionEnter2D`）对玩家造成伤害的逻辑。与玩家碰撞时，获取`PlayerStats`组件并减少其HP。增加短暂的攻击间隔（通过状态机实现）以防止每帧都造成伤害。 | 让敌人撞向玩家。玩家的HP应该会减少。敌人攻击后会后退，不会持续黏着玩家造成伤害。 |
| **2.6**| **单位死亡**：在`EnemyStats`中，检查HP是否<=0。如果是，则销毁敌人对象并给予玩家EXP。在`PlayerStats`中，检查HP是否<=0。如果是，则触发"游戏结束"状态（如显示信息、冻结游戏）。 | 攻击一个敌人直至其HP为0；它应该会消失，同时玩家的EXP增加。让敌人攻击玩家直至HP为0；游戏结束状态被触发。 |

---

## 里程碑 3: 蛊系统（MVP）

**目标**: 实现游戏核心的、基于输入的蛊虫施法系统，包含标准化的目标选择机制。

| 步骤 | 实施指令 | 测试标准 |
| :--- | :--- | :--- |
| **3.1**| **蛊的数据结构**：使用`ScriptableObject`来定义蛊。创建一个`GuData`基类（包含名字、描述、类型等）。创建`TargetedDamageGuData`子类，拥有AP加成系数和目标效果逻辑。 | 在项目中创建一个新的伤害蛊资源（如 "喷火蛊"）。填写其数据。数据应被正确保存在资源文件中。 |
| **3.2**| **玩家蛊管理器**：在玩家身上创建一个`PlayerGuManager`脚本。该脚本持有两个`GuData`列表：`allOwnedGu` 和 `equippedGu`。当前阶段，在Inspector中手动将 "喷火蛊" 添加到两个列表中。 | 进入播放模式，检视玩家对象。蛊管理器中应显示已拥有的和已装备的 "喷火蛊"。 |
| **3.3**| **施法状态机**：创建一个`GuCasting`脚本。实现状态机来处理施法流程：`空闲` -> `选择类型` -> `输入指令` -> `（可选）选择目标` -> `施法`。按下 'J' 键从 `空闲` 进入 `选择类型` 状态。 | 进入播放模式，按下 'J' 键，日志应显示状态变为 "选择类型"。在任何时候按下 'C' 键应能使状态返回 "空闲"。 |
| **3.4**| **类型选择与指令分配**：在`选择类型`状态下，监听 'I', 'K', ',' 输入。选择后，筛选出对应类型的已装备蛊。为每个找到的蛊分配一个唯一的3字母随机指令。**逻辑**：指令生成必须确保在本次施法会话中，同类型蛊的指令不会重复。进入`输入指令`状态。 | 装备两个伤害蛊。按下 'J'，然后按 'I'。日志应显示两个蛊以及它们各自不同的3字母指令（例如 "蛊A: OIP", "蛊B: POI"）。 |
| **3.5**| **指令输入与准备**：在`输入指令`状态下，监听键盘输入构建3字母字符串。输入完成后，检查是否与指令匹配。如果匹配，则"准备"好对应的蛊。根据蛊是否需要目标，决定进入`选择目标`状态或直接等待最终施法。 | 接上一步测试。输入其中一个指令。日志应确认对应蛊已"准备"。 |
| **3.6**| **目标选择系统**：在`选择目标`状态下，在一个`TargetingManager`的驱动下，所有屏幕内的有效敌人头顶出现一个唯一的4字母随机字符串UI（**字符串的字母将从'I', 'O', 'P', 'K', 'L', ';'中抽取**）。玩家此时需要输入目标对应的字符串。输入正确后，该敌人被锁定为目标。**逻辑**: 在进入此状态时，检查`PlayerStats.SoulForce`。如果达到阈值（如50），则调用`TimeManager.RequestTimeScale("TargetingSlowMo", 0.5f)`来减缓游戏速度。 | 准备一个需要目标的蛊。场景中有多个敌人。进入`选择目标`状态，所有敌人头顶都出现一个由指定字符集构成的字符串。如果玩家魂力足够，游戏整体速度应明显变慢。输入其中一个字符串，对应敌人被高亮或标记为"已锁定"。 |
| **3.7**| **执行蛊的效果**：再次按下 'J' 键，执行已准备好的蛊的效果。创建一个`GuExecutor`脚本，根据传入的`GuData`和（可选的）目标来执行效果。对于"喷火蛊"，如果锁定了目标，就在目标位置实例化一个爆炸效果；如果没有，则向前发射投射物。**逻辑**: 在施法完成后，若之前请求了时间减速，必须调用`TimeManager.ReleaseTimeScale("TargetingSlowMo")`来恢复正常速度。 | 成功施放"喷火蛊"。如果已锁定目标，在目标身上产生伤害。如果没有，则向前发射的投射物能对击中的敌人造成伤害。施法结束后，游戏速度恢复正常。 |

---

## 里程碑 4: 成长与界面

**目标**: 建立玩家的成长体系，并创建必要的UI来反馈游戏状态。

| 步骤 | 实施指令 | 测试标准 |
| :--- | :--- | :--- |
| **4.1**| **经验与升级**：在`PlayerStats`中，创建一个`LevelUp`方法。定义下一级的经验需求（如 `100 * 当前等级`）。在`AddEXP`方法中，检查当前经验是否满足需求。如果满足，则调用`LevelUp`。 | 击杀敌人获得经验。当经验达到阈值时，玩家的等级应增加，经验值应重置（或扣除升级所需部分）。 |
| **4.2**| **基础UI - 玩家状态**：创建一个UI `Canvas`。添加`Text`或`TextMeshPro`元素来显示玩家的 当前/最大HP、当前/最大MP、等级。创建一个`UIManager`脚本从`PlayerStats`获取数据，并在数值变化时更新UI。UI需要能响应`isBreakthroughPending`状态。 | 开始游戏，UI应显示初始状态。当玩家受伤时，HP文本应更新。当`isBreakthroughPending`为true时，应有明确的视觉提示。 |
| **4.3**| **基础UI - 施法**：添加UI元素为施法过程提供反馈。在`选择类型`状态时显示提示文本。当指令被分配后，显示蛊和其对应指令的列表。当进入`选择目标`状态时，隐藏蛊指令UI并显示目标头顶的字符串。 | 完整地执行一次施法流程。UI应为流程的每一步提供清晰、实时的反馈，包括目标选择阶段。 |
| **4.4**| **破镜挑战（功能模拟）**：在`PlayerStats`的`LevelUp`方法中，不直接提升等级，而是设置 `isBreakthroughPending = true`。当此标记为`true`时，显示UI按钮"尝试破镜"。点击它会触发破镜逻辑：模拟一次有失败几率的尝试。如果失败，玩家当前EXP损失10%；如果成功，`isBreakthroughPending`设为`false`并实际提升等级。 | 获得足够经验后，玩家等级不变，"尝试破镜"按钮出现。点击它，根据结果，玩家等级提升或EXP减少。按钮随之消失。 |

---

## 里程碑 5: 游戏循环与持久化

**目标**: 建立游戏的基本循环（战斗/休整），并实现保存和加载游戏进度的功能。

| 步骤 | 实施指令 | 测试标准 |
| :--- | :--- | :--- |
| **5.1**| **安全区/枢纽地图**：创建一个新的、简单的"安全区"场景。它是一个没有敌人的区域。创建一个"传送点"预制件。在荒野地图和安全区地图中各放置一个，用于场景切换。 | 玩家可以走进荒野中的传送点，然后被加载到安全区场景。走进安全区中的传送点可以返回荒野。 |
| **5.2**| **待保存的数据结构**：创建一个`SaveData`类。此类为纯C#对象，包含所有需要保存的数据字段：玩家所有属性（等级、经验等）、一个包含所有已拥有蛊ID的列表、一个包含所有已装备蛊ID的列表、当前场景名和玩家位置。 | 创建一个`SaveData`实例，并用各管理器脚本中的当前玩家数据填充它。通过日志打印`SaveData`对象的内容，确保两个蛊列表和其它数据都填充正确。 |
| **5.3**| **存档系统**：创建一个`SaveManager`。实现`SaveGame(int slotNumber)`方法。此方法将填充一个`SaveData`对象，将其序列化为JSON，并写入文件（如 `save_slot_1.json`）。在游戏菜单中添加一个"保存"按钮来调用此方法。 | 玩一会游戏，获得/切换一些蛊。点击保存按钮。验证在游戏数据路径下创建了一个`.json`文件，并且其内容（特别是蛊列表）是正确的。 |
| **5.4**| **读档系统**：在`SaveManager`中，实现`LoadGame(int slotNumber)`方法。此方法将读取JSON文件，反序列化回`SaveData`对象，然后将数据应用到游戏状态中（更新`PlayerStats`，清空并用存档数据重建`PlayerGuManager`中的蛊列表，加载正确的场景，移动玩家到保存的位置）。在主菜单添加"加载游戏"按钮。 | 关闭并重启游戏。从主菜单加载之前保存的游戏。玩家应该出现在正确的位置，拥有正确的属性，并且`PlayerGuManager`中的蛊列表与存档文件中的完全一致。 | 